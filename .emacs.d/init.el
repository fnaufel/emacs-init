;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;                      ATTENTION
;;;
;;; This file was automatically generated by org-babel-tangle
;;; from file /home/fnaufel/Stow/emacs/dot-emacs.org.
;;;
;;; DO NOT MODIFY THIS FILE.
;;;
;;; To change these configs, edit
;;; /home/fnaufel/Stow/emacs/dot-emacs.org instead.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The default is 800 kilobytes.  Measured in bytes.
(setq gc-cons-threshold (* 100 1000 1000))

;; Profile emacs startup
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                     (emacs-init-time)
                     gcs-done)))

(defun my/tangle-async ()
    "Tangle asynchronously current file."
    (let ((file (buffer-file-name)))
      (async-start
       `(lambda ()
          (require 'org)
          (org-babel-tangle-file ,file))
       `(lambda (result)
          (message (format "tangle-async finished for: %s" result))))))

(setq custom-file "~/Stow/emacs/.emacs.d/.emacs-custom.el")
(load custom-file)

(server-start)

(require 'package)

(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl (warn "\
Your version of Emacs does not support SSL connections,
which is unsafe because it allows man-in-the-middle attacks.
There are two things you can do about this warning:
1. Install an Emacs version that does support SSL and be safe.
2. Remove this warning from your init file so you won't see it again."))
(add-to-list 'package-archives
             (cons "melpa" (concat proto "://melpa.org/packages/")) t))

(add-to-list 'package-archives
             '("melpa-stable" . "http://stable.melpa.org/packages/") t)

(add-to-list 'package-archives
             '("gnu" . "http://elpa.gnu.org/packages/") t)

(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/") t)

(package-initialize)

(add-to-list 'load-path "/home/fnaufel/.emacs.d/lisp/")

(package-refresh-contents)

(require 'paradox)
(paradox-enable)

(require 'org-autolist)
(add-hook 'org-mode-hook (lambda () (org-autolist-mode)))

;; org-superstar
(require 'org-superstar)
(add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))

;; set basic title font
(set-face-attribute 'org-level-8 nil :weight 'bold :inherit 'default :foreground "dark orange")

;; ;; Low levels are unimportant => no scaling
(set-face-attribute 'org-level-7 nil :inherit 'org-level-8)
(set-face-attribute 'org-level-6 nil :inherit 'org-level-8)
(set-face-attribute 'org-level-5 nil :inherit 'org-level-8)
(set-face-attribute 'org-level-4 nil :inherit 'org-level-8)
(set-face-attribute 'org-level-3 nil :inherit 'org-level-8 :height 1.05) 
(set-face-attribute 'org-level-2 nil :inherit 'org-level-8 :height 1.1) 
(set-face-attribute 'org-level-1 nil :inherit 'org-level-8 :height 1.15)

;; (require 'org-bars)
;; (add-hook 'org-mode-hook #'org-bars-mode)

;; ;; No ellipsis in headlines
;; (defun org-no-ellipsis-in-headlines ()
;;   "Remove use of ellipsis in headlines.
;; See `buffer-invisibility-spec'."
;;   (remove-from-invisibility-spec '(outline . t))
;;   (add-to-invisibility-spec 'outline))

;; (add-hook 'org-mode-hook 'org-no-ellipsis-in-headlines)

;; Fix this function to handle blank, non-empty entries
;; (defun org-bars-subtree-is-empty-p ()
  ;; "Return t if subtree at point is empty."
  ;; (let ((entry (org-get-entry)))
    ;; (set-text-properties 0 (length entry) nil entry)
    ;; (string-blank-p entry)))

(require 'calfw)
(require 'calfw-org)

(global-set-key (kbd "s-c") 'cfw:open-org-calendar)

;; use org agenda buffer style keybinding.
(setq cfw:org-overwrite-default-keybinding t)

;;; Shorter key bindings for next and previous link
(add-hook 'org-load-hook
          (lambda ()
            (define-key org-mode-map (kbd "\C-n") 'org-next-link)
            (define-key org-mode-map (kbd "\C-p") 'org-previous-link)))

(global-set-key "\C-ck" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(define-key org-mode-map "\C-n" 'org-next-link)
(define-key org-mode-map "\C-p" 'org-previous-link)
(define-key org-mode-map "\C-c\C-xi" 'org-insert-columns-dblock)

;;; helm-org
(define-key org-mode-map (kbd "C-c j") 'helm-org-in-buffer-headings)
(define-key org-mode-map (kbd "C-c C-j") 'helm-org-in-buffer-headings)
(define-key org-mode-map (kbd "C-c i") 'helm-org-parent-headings)
(define-key org-mode-map (kbd "C-c g") 'helm-org-agenda-files-headings)

(require 'hydra)
(require 'major-mode-hydra)
(require 'pretty-hydra)

(defun with-faicon (icon str &optional height v-adjust)
  (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

(defun with-fileicon (icon str &optional height v-adjust)
  (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

(defun with-octicon (icon str &optional height v-adjust)
  (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

(defun with-material (icon str &optional height v-adjust)
  (s-concat (all-the-icons-material icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

(defun with-mode-icon (mode str &optional height nospace face)
  (let* ((v-adjust (if (eq major-mode 'emacs-lisp-mode) 0.0 0.05))
         (args     `(:height ,(or height 1) :v-adjust ,v-adjust))
         (_         (when face
                      (lax-plist-put args :face face)))
         (icon     (apply #'all-the-icons-icon-for-mode mode args))
         (icon     (if (symbolp icon)
                       (apply #'all-the-icons-octicon "file-text" args)
                     icon)))
    (s-concat icon (if nospace "" " ") str)))

(defun convert-hhmmss-to-secs (time)
  "Receives a string of digits TIME of the form h...hhmmss and
  returns the corresponding total number of seconds. If TIME is
  nil, or the empty string, return nil." 

  (unless (or (null time)(string= time ""))
    (let ((secs (string-to-int time))   ; if only secs, this is enough
          (mins 0)
          (hrs 0)
          (l (length time)))
      (when (> l 2)                     ; there are minutes!
        (progn 
          (setq secs (string-to-int (substring time -2)))     ; must correct secs
          (setq mins (string-to-int (substring time 0 -2))))) ; if no hours, enough
      (when (> l 4)                     ; there are hours!
        (progn 
          (setq mins (string-to-int (substring time -4 -2))) ; must correct minutes
          (setq hrs (string-to-int (substring time 0 -4))))) ; get hours
      (+ secs (* 60 mins) (* 3600 hrs)))))

(defvar video-link-function 'gmplayer-seek 
  "*Function used in org mode to open video links.")

(defun gmplayer-seek (file &optional time1 time2)
  "Start asynchronous instance of gnome-mplayer to play FILE,
  optionally starting from time TIME1 and ending at time TIME2.
  Both time arguments are of the form h...hhmmss (with no
  separators). If fewer than 6 digits are present, those present
  are the least significant; e.g., 123 = 1 minute and 23 seconds."

  (let ((t1 (convert-hhmmss-to-secs time1))
        (t2 (convert-hhmmss-to-secs time2))) 
    (cond ((and t1 t2)                ; recall t2 is end time
           (setq t2 (- t2 t1))        ; make t2 duration of playback
           (message "Opening %s  (from %s to %s)" file time1 time2)
           (start-process "org-gmplayer"                     ; process name
                          (concat file "::" time1 "-" time2) ; buffer name
                          "/usr/bin/gnome-mplayer"           ; program
                          "--ss"                             ; args
                          (int-to-string t1)
                          "--endpos" 
                          (int-to-string t2)
                          "-v"
                          file))
          (t1 
           (message "Opening %s  (from %s)" file time1)
           (start-process "org-gmplayer" 
                          (concat file "::" time1) 
                          "/usr/bin/gnome-mplayer"
                          "--ss" 
                          (int-to-string t1)
                          "-v"
                          file))
          (t 
           (message "Opening %s" file)
           (start-process "org-gmplayer" 
                          file 
                          "/usr/bin/gnome-mplayer"
                          "-v"
                          file)))))

(defvar audio-link-function 'audacious-seek 
  "*Function used in org mode to open audio links.")

(defun audacious-seek (file &optional time1)
  "Start asynchronous instance of audacious to play FILE,
  optionally starting from time TIME1. The TIME1 argument is of
  the form h...hhmmss (with no separators). If fewer than 6
  digits are present, those present are the least significant;
  e.g., 123 = 1 minute and 23 seconds."

  (let ((t1 (convert-hhmmss-to-secs time1)))
    (cond (t1 
           (message "Opening %s  (from %s)" file time1)
           (start-process "org-audacious" 
                          (concat file "::" time1) 
                          "/usr/bin/audacious"
                          file)
           (sleep-for 0 500)
           (start-process "org-audtool" 
                          (concat file "::" time1) 
                          "/usr/bin/audtool"
                          "playback-seek"
                          (int-to-string t1)))
          (t 
           (message "Opening %s" file)
           (start-process "org-audacious" 
                          file 
                          "/usr/bin/audacious"
                          file)))))

(require 'org-journal)

(global-unset-key (kbd "C-c C-j"))
(global-set-key (kbd "C-c s") 'org-journal-search)
(global-set-key (kbd "C-J") 'org-journal-new-entry)
(define-key org-mode-map (kbd "C-J") 'org-journal-new-entry)

;; Turn on Auto Fill mode automatically in Org mode
(add-hook 'org-mode-hook
          '(lambda ()
             (turn-on-auto-fill)))

;; Auto numbering of headlines
(add-hook 'org-mode-hook (lambda () (org-num-mode)))

;; org-tempo
(require 'org-tempo)

;;; Associate .org files to org mode
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))

;;; Associate claws-mail compose files to org mode
(add-to-list 'auto-mode-alist '("\\.0x.*$" . org-mode))

;;; Clock
(setq org-clock-persist t)
(org-clock-persistence-insinuate)

(defun update-clock-tables ()
  "Visit todo.org, update all dynamic blocks there, and save."

  (find-file "/home/fnaufel/Documents/OrgFiles/todo.org")
  (org-show-all '(headings))
  (org-update-all-dblocks)
  (save-buffer))

;;; cdlatex mode
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)

(global-set-key (kbd "s--") 'negative-argument)
(global-set-key (kbd "s-0") 'digit-argument)
(global-set-key (kbd "s-1") 'digit-argument)
(global-set-key (kbd "s-2") 'digit-argument)
(global-set-key (kbd "s-3") 'digit-argument)
(global-set-key (kbd "s-4") 'digit-argument)
(global-set-key (kbd "s-5") 'digit-argument)
(global-set-key (kbd "s-6") 'digit-argument)
(global-set-key (kbd "s-7") 'digit-argument)
(global-set-key (kbd "s-8") 'digit-argument)
(global-set-key (kbd "s-9") 'digit-argument)

(menu-bar-mode 0)

;;; Set font
(defun fontify-frame (frame)
  (set-frame-parameter frame 'font "Jetbrains Mono-13"))

;; Fontify current frame
(fontify-frame nil)

;; Fontify any future frames
(push 'fontify-frame after-make-frame-functions)

(require 'all-the-icons)

(require 'which-key)
(which-key-mode)

(require 'anzu)
(global-anzu-mode +1)

(require 'helpful) 

;; Note that the built-in `describe-function' includes both functions
;; and macros. `helpful-function' is functions only, so we provide
;; `helpful-callable' as a drop-in replacement.
(global-set-key (kbd "C-h f") #'helpful-callable)
(global-set-key (kbd "C-h v") #'helpful-variable)
(global-set-key (kbd "C-h k") #'helpful-key)

;; Lookup the current symbol at point. C-c C-d is a common keybinding
;; for this in lisp modes.
(global-set-key (kbd "C-c C-d") #'helpful-at-point)

;; Look up *F*unctions (excludes macros).
;;
;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
;; already links to the manual, if a function is referenced there.
(global-set-key (kbd "C-h F") #'helpful-function)

;; Look up *C*ommands.
;;
;; By default, C-h C is bound to describe `describe-coding-system'. I
;; don't find this very useful, but it's frequently useful to only
;; look at interactive functions.
(global-set-key (kbd "C-h C") #'helpful-command)

(require 'info-colors)
(add-hook 'Info-selection-hook 'info-colors-fontify-node)

(require 'expand-region)
(global-set-key (kbd "C-+") 'er/expand-region)

(require 'smartparens-config)
(smartparens-global-mode 1)
(show-smartparens-global-mode t)

;;; markdown-mode etc
(sp-with-modes '(markdown-mode gfm-mode rst-mode org-mode)
  (sp-local-pair "*" "*")
  (sp-local-pair "/" "/")
;  (sp-local-pair "_" "_")
)

(defun sp-select-up ()
  (interactive)

  (sp-backward-up-sexp)
  (sp-select-next-thing)
)

(define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)
(define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)

(define-key smartparens-mode-map (kbd "C-S-p") 'sp-previous-sexp)
(define-key smartparens-mode-map (kbd "C-S-n") 'sp-next-sexp)

(define-key smartparens-mode-map (kbd "C-M-d") 'sp-down-sexp)
(define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)

(define-key smartparens-mode-map (kbd "C-S-a") 'sp-beginning-of-sexp)
(define-key smartparens-mode-map (kbd "C-S-e") 'sp-end-of-sexp)

(define-key smartparens-mode-map (kbd "C-M-t") 'sp-transpose-sexp)

(define-key smartparens-mode-map (kbd "C-M-k") 'sp-kill-sexp)
(define-key smartparens-mode-map (kbd "C-M-w") 'sp-copy-sexp)

(define-key smartparens-mode-map (kbd "C-]") 'sp-select-up)
(define-key smartparens-mode-map (kbd "C-}") 'sp-select-next-thing)

(require 'multiple-cursors)

;; When you have an active region that spans multiple lines, the
;; following will add a cursor to each line:
(global-set-key (kbd "C-|") 'mc/edit-lines)

;; When you want to add multiple cursors not based on continuous
;; lines, but based on keywords in the buffer, use the keys below.
;; First mark the word, then add more cursors.
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-?") 'mc/mark-all-like-this-dwim)
(global-set-key (kbd "C-.") 'mc/mark-sgml-tag-pair)

;; To get out of multiple-cursors-mode, press `<return>` or `C-g`. The
;; latter will first disable multiple regions before disabling
;; multiple cursors.

;; If you want to insert a newline in multiple-cursors-mode, use
;; `C-j`.

(if (require 'sml-modeline nil 'noerror)    ;; use sml-modeline if available
  (progn 
    (sml-modeline-mode 1)                   ;; show buffer pos in the mode line
    (scroll-bar-mode -1))                   ;; turn off the scrollbar
  (scroll-bar-mode 1)                       ;; otherwise, show a scrollbar...
  (set-scroll-bar-mode 'right))             ;; ... on the right

;; Enable recent files menu
(recentf-mode)

;; ffap-bindings binds C-x C-r to ffap-read-only.
;; I prefer to have it bound to recentf-open-files.
(global-set-key "\C-x\C-r" 'recentf-open-files)

;;; Copy line at point
(defun copy-line ()
  "Copy line at point."
  (interactive)
  (save-excursion
    (setq text (thing-at-point 'line t))
    (kill-new text)
    (princ "Line copied to kill ring." t)))

(global-set-key (kbd "C-s-<up>") 'copy-line)

;;; Duplicate line
(defun duplicate-line ()
  "Duplicate line at point on a new line below. Point remains in original line."
  (interactive)
  (save-excursion
    (setq text (thing-at-point 'line t))
    (when (string-suffix-p "\n" text)
      (setq text (substring text 0 -1)))
    (move-end-of-line nil)
    (insert (concat "\n" text))))

(global-set-key (kbd "C-s-<down>") 'duplicate-line)

;;; Generate numbered items (one per line) according to template 
(defun gen-numbered-items (first last template)
  "Generate numbered items (one per line) according to template."

  (interactive "*nFirst number: \nnLast number: \nMTemplate: ")

  (setq i first)
  (while (not (> i last))
    (progn
      (insert (format template i) "\n")
      (setq i (1+ i)))))

(setq hydra-fnjump--title
  (with-faicon "map-signs" "Important places" 1 -0.05))

(pretty-hydra-define hydra-fnjump
  (:quit-key "q" :title hydra-fnjump--title :foreign-keys warn :exit t)
  ("Jump to"
   (("e" (find-file "~/Documents/OrgFiles/mail.org") "email ")
    ("b" (find-file "~/.bashrc") ".bashrc ")
    ("p" (find-file "~/.profile") ".profile ")
    ("s" (find-file "~/Stow") "Stow ")
    ("i" (find-file "~/Stow/emacs/dot-init.org") "init ")
    ("t" (update-clock-tables) "clock tables ")
    ("x" (ansi-term "/home/fnaufel/.local/bin/xonsh" "xonsh") "new xonsh "))

   "Quit"
   (("q" nil "quit "))))

(global-set-key (kbd "s-j") 'hydra-fnjump/body)

(defadvice yank-pop (around kill-ring-browse-maybe (arg))
  "If last action was not a yank, run `browse-kill-ring' instead."
  (if (not (eq last-command 'yank))
      (browse-kill-ring)
    ad-do-it))

(ad-activate 'yank-pop)

;; Turn on Auto Fill mode automatically in Text mode and related modes
(add-hook 'text-mode-hook
          '(lambda () (turn-on-auto-fill)))

(require 'iso-transl)

;;; Insert nobreakspace
(defun insert-nbsp ()
  "Insert nobreakspace (code 160)"
  (interactive)
  (insert 160)
)

(global-set-key (kbd "C-;") 'insert-nbsp)

;;; Position point at window center, top, bottom
(defvar cycle-window-line-last-op 'middle
  "Indicates the last cycle-window-line operation performed.
Possible values: `top', `middle', `bottom'.")

(defun cycle-window-line (&optional arg)
  "Move point to window center, bottom, and top, successively.

A prefix argument is handled like `move-to-window-line':
 With numeric prefix ARG, move point to window-line ARG."

  (interactive "P")
  (cond
   (arg (move-to-window-line arg))                 ; Always respect ARG.
   ((or (not (eq this-command last-command))
    (eq cycle-window-line-last-op 'top))
    (setq cycle-window-line-last-op 'middle)
    (move-to-window-line nil))
   (t
    (cond ((eq cycle-window-line-last-op 'middle)
           (setq cycle-window-line-last-op 'bottom)
           (move-to-window-line -1))
          ((eq cycle-window-line-last-op 'bottom)
           (setq cycle-window-line-last-op 'top)
           (move-to-window-line 0))))))

;;; Scroll one line at a time. 
(defun scroll-n-lines-ahead (&optional n)
  "Scroll ahead N lines (1 by default)."
  (interactive "P")
  (let ((save-scroll-preserve scroll-preserve-screen-position))
    (setq scroll-preserve-screen-position nil)
    (scroll-up (prefix-numeric-value n))
    (setq scroll-preserve-screen-position save-scroll-preserve)))

(defun scroll-n-lines-behind (&optional n)
  "Scroll behind N lines (1 by default)."
  (interactive "P")
  (let ((save-scroll-preserve scroll-preserve-screen-position))  
    (setq scroll-preserve-screen-position nil)
    (scroll-down (prefix-numeric-value n))
    (setq scroll-preserve-screen-position save-scroll-preserve)))

(global-set-key "\M-r" 'cycle-window-line)
(global-set-key (kbd "C-*") 'scroll-n-lines-ahead)
(global-set-key (kbd "C-/") 'scroll-n-lines-behind)

(global-set-key (kbd "C-c u") 'org-mark-ring-goto)
(global-set-key (kbd "C-<insert>") 'kill-ring-save)
(global-set-key (kbd "C-<return>") 'cua-rectangle-mark-mode)
(define-key org-mode-map (kbd "C-<return>") 'cua-rectangle-mark-mode)

(global-set-key (kbd "C-x C-b") 'buffer-menu)

;;; Maximize frame
(defun maximize-current-frame () 
  (set-frame-parameter nil 'fullscreen 'maximized))

;;; Set background of hl-line
(set-face-background hl-line-face "gray20")

(defun prev-window ()
  (interactive)
  (other-window -1))

(global-set-key (kbd "<s-tab>") 'other-window)
(global-set-key (kbd "<S-s-iso-lefttab>") 'prev-window)

(require 'windmove)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

;; Regexes for names of buffers that should not be killed by this function
(setq not-to-kill-buffer-list
      '("\\*scratch\\*"
        "#emacs"
        "\\*Messages\\*"
        "\\*shell\\*"
        "\\*xonsh\\*"
        "Sunrise Tree$"
        "Sunrise Tree<2>$"
        " (Sunrise)$"
        "\\*Org Src"))

(defun kill-or-bury-current-buffer ()
  "If current buffer name is on not-to-kill-buffer-list, bury.
Otherwise, kill."
  (interactive)
  (let ((case-fold-search nil))
    (if (seq-some
         (lambda (x) (string-match-p x (buffer-name (current-buffer))))
         not-to-kill-buffer-list)
        (bury-buffer)
      (kill-buffer (current-buffer)))))

(defun kill-buffer-special-and-window ()
  "If current buffer name is on not-to-kill-buffer-list, bury.
Otherwise, kill. Besides, if not sole window, delete current window."
  (interactive)
  (kill-or-bury-current-buffer)
  (unless (one-window-p)
    (delete-window)))

(defun kill-buffer-special-and-frame ()
  "If current buffer name is on not-to-kill-buffer-list, bury.
Otherwise, kill. Besides, delete current frame."
  (interactive)
  (kill-or-bury-current-buffer)
  (delete-frame))

(defun kill-other-buffer-special ()
  "If other buffer name is on not-to-kill-buffer-list, bury.
Otherwise, kill."
  (interactive)
  (unless (one-window-p)
    (save-excursion
      (other-window 1)
      (kill-or-bury-current-buffer))))

(defun kill-other-buffer-special-and-window ()
  "If other buffer name is on not-to-kill-buffer-list, bury.
Otherwise, kill. Besides, delete window it occupied."
  (interactive)
  (unless (one-window-p)
    (save-excursion
      (other-window 1)
      (kill-or-bury-current-buffer)
      (delete-window))))

(require 'buffer-move)

(setq hydra-window--title
  (with-faicon "clone" "Buffers, windows, frames" 1 -0.05))

(pretty-hydra-define hydra-windows
  (:quit-key "q" :title hydra-window--title :foreign-keys warn)
    ("Go"
     (("i" windmove-up "↑ ")
      ("m" windmove-down "↓ ")
      ("j" windmove-left "← ")
      ("l" windmove-right "→ "))

     "Resize"
     (("I" hydra-move-splitter-up "↑ ")
      ("M" hydra-move-splitter-down "↓ ")
      ("J" hydra-move-splitter-left "← ")
      ("L" hydra-move-splitter-right "→ ")
      ("=" balance-windows "= "))

     "Swap"
     (("M-i" buf-move-up "↑ ")
      ("M-m" buf-move-down "↓ ")
      ("M-j" buf-move-left "← ")
      ("M-l" buf-move-right "→ "))

     "Kill"
     (("k" kill-or-bury-current-buffer "this buffer ")
      ("K" kill-buffer-special-and-window "this buffer & window ")
      ("M-k" kill-buffer-special-and-frame "this buffer & frame " :exit t)
      ("o" kill-other-buffer-special "other buffer ")
      ("O" kill-other-buffer-special-and-window "other buffer & window "))

     "Create"
     (("w" (progn (split-window-below) (windmove-down)) "window ↑ ")
      ("s" (split-window-below) "window ↓ ")
      ("a" (progn (split-window-right) (windmove-right)) "window ← ")
      ("d" (split-window-right) "window → ")
      ("f" make-frame-command "frame " :exit t))

     "Delete"
     (("0" delete-window "this window ")
      ("1" delete-other-windows "other windows ")
      ("5" delete-frame "this frame " :exit t))

     "Quit"
     (("q" nil "quit "))))

(global-set-key (kbd "s-l") 'hydra-windows/body)
(global-set-key (kbd "s-k") 'kill-or-bury-current-buffer)

(global-set-key (kbd "C-x C-y") 'transpose-sentences)
(global-set-key (kbd "C-z") 'undo)

;; (setq xah-fly-use-meta-key nil)
;; (setq xah-fly-use-control-key nil)
;; (require 'xah-fly-keys)
;; (xah-fly-keys-set-layout "qwerty-abnt")
;; (xah-fly-keys 1)

(require 'web-beautify)

(require 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

(global-display-line-numbers-mode t)

;; Disable line numbers for some modes
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
                help-mode-hook
                treemacs-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

(require 'js2-mode)
(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
(add-to-list 'auto-mode-alist '("\\.ts\\'" . js2-mode))

(require 'skewer-mode)

(add-to-list 'interpreter-mode-alist
             '("python3" . python-mode))

(require 'zeal-at-point)
(global-set-key (kbd "s-h") 'zeal-at-point)

(require 'lsp)

;; Modes for which to enable lsp
(dolist (mode '(html-mode-hook
                c-mode-hook
                c++-mode-hook
                css-mode-hook
                js-mode-hook
                ;; sh-mode-hook
                java-mode-hook
                python-mode-hook
                sgml-mode-hook
                yaml-mode-hook))
  (add-hook mode #'lsp))

(define-key lsp-mode-map (kbd "<tab>") 'company-indent-or-complete-common)
(define-key lsp-mode-map (kbd "<s-kp-add>") lsp-command-map)
(setq lsp-keymap-prefix "<s-kp-add>")

(defun efs/lsp-mode-setup ()
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (lsp-headerline-breadcrumb-mode))

(add-hook 'lsp-mode-hook 'efs/lsp-mode-setup)

(lsp-enable-which-key-integration 1)

(require 'lsp-ui)
(add-hook 'lsp-mode-hook 'lsp-ui-mode)
(setq lsp-ui-doc-position 'bottom)

(require 'lsp-treemacs)
(lsp-treemacs-sync-mode 1)

(require 'helm-lsp)
; C-M-.
(define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol)

(require 'projectile)

(projectile-mode +1)
(define-key projectile-mode-map (kbd "<s-kp-enter>") 'projectile-command-map)

(setq projectile-completion-system 'helm)
(setq projectile-project-search-path '("~/Development/00-Present"))

(require 'helm-projectile)
(helm-projectile-on)

(setq markdown-asymmetric-header t)
(setq markdown-enable-math t)

(require 'polymode)
(require 'poly-markdown)
(require 'poly-R)

;; associate the new polymode to Rmd files:
(add-to-list 'auto-mode-alist
             '("\\.[rR]md\\'" . poly-gfm+r-mode))

;; uses braces around code block language strings:
(setq markdown-code-block-braces t)

(require 'markdown-mode)
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

(require 'markdown-toc)

(require 'yaml-mode)
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
(add-hook 'yaml-mode-hook
          '(lambda ()
             (define-key yaml-mode-map "\C-m" 'newline-and-indent)))

(global-set-key [remap dabbrev-expand] 'hippie-expand)

(require 'company)

;; elisp
(add-hook 'ielm-mode-hook 'company-mode)
(add-hook 'emacs-lisp-mode-hook 'company-mode)
(add-hook 'lsp-mode-hook 'company-mode)

(global-set-key (kbd "<s-return>") 'company-complete)
(define-key company-active-map (kbd "<tab>") 'company-complete-selection)
(define-key company-active-map (kbd "<ESC>") 'company-abort)

(setq company-minimum-prefix-length 3)
(setq company-idle-delay 0.5)

;;; This apparently keeps company popups from showing
;; (require 'company-box)
;; (add-hook 'company-mode-hook 'company-box-mode)

(require 'yasnippet)
(yas-global-mode 1)
;;; Turn off yasnippet for xonsh terminal
(add-hook 'term-mode-hook (lambda()
                (yas-minor-mode -1)))

;;; https://orgmode.org/manual/Conflicts.html#Conflicts
(defun yas/org-very-safe-expand ()
  (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

(add-hook 'org-mode-hook
          (lambda ()
            (make-variable-buffer-local 'yas/trigger-key)
            (setq yas/trigger-key [tab])
            (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
            (define-key yas/keymap [tab] 'yas/next-field)))

(require 'helm-config)

;; From http://tuhdo.github.io/helm-intro.html
;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
(global-set-key (kbd "C-c h") 'helm-command-prefix)
(global-unset-key (kbd "C-x c"))
(global-set-key (kbd "C-x b") 'helm-mini)

(when (executable-find "curl")
  (setq helm-google-suggest-use-curl-p t))

(setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
      helm-buffers-fuzzy-matching           t ; fuzzy matching buffer names when non--nil
      helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
      helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
      helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
      helm-ff-file-name-history-use-recentf t)

(helm-mode 1)
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
(define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

(define-key helm-map (kbd "C-<left>")  'helm-previous-source) 
(define-key helm-map (kbd "C-<right>")  'helm-next-source) 
(define-key helm-map (kbd "<left>")  'backward-char) 
(define-key helm-map (kbd "<right>")  'forward-char) 

(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-c b") 'helm-buffers-list)
(add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
(global-set-key (kbd "C-c h o") 'helm-occur)
(global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)

;;; Make helm use new frame instead of minibuffer
(setq helm-display-function 'helm-display-buffer-in-own-frame
        helm-display-buffer-reuse-frame t
        helm-use-undecorated-frame-option t)

(require 'bash-completion)
(bash-completion-setup)

;;; Fix junk characters in shell mode
(autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
(add-to-list 'comint-output-filter-functions 'ansi-color-process-output)

;;; Force save comint-input-ring upon killing emacs
(add-hook 'kill-emacs-hook 'comint-write-input-ring)

;; (require 'xonsh-mode)

;; ;;; Bind yank
;; (eval-after-load "term"
;;   '(progn 
;;      (define-key term-raw-map (kbd "C-c C-y") 'term-paste)
;;      (define-key term-raw-map (kbd "C-y") 'term-paste)))

(load "ltx-help")

;;; Corrected version. See http://www.emacswiki.org/emacs/AUCTeX#toc8
(defun latex-help-get-cmd-alist ()
  "Scoop up the commands in the index of the latex info manual.
          The values are saved in `latex-help-cmd-alist' for speed."
  ;; mm, does it contain any cached entries
  (if (not (assoc "\\begin" latex-help-cmd-alist))
      (save-window-excursion
        (setq latex-help-cmd-alist nil)
        (Info-goto-node (concat latex-help-file "Command Index"))
        (end-of-buffer)
        (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
          (setq key (ltxh-buffer-substring (match-beginning 1) (match-end 1)))
          (setq value (ltxh-buffer-substring (match-beginning 2) (match-end 2)))
          (setq latex-help-cmd-alist
                (cons (cons key value) latex-help-cmd-alist))))
    )
  latex-help-cmd-alist
  ) 

;;; LaTeX help
(define-key help-map "\C-l" 'latex-help)

(add-hook 'LaTeX-mode-hook 'turn-on-auto-fill)
(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
(add-hook 'LaTeX-mode-hook 
          (function (lambda ()
                      (define-key LaTeX-mode-map "\C-ci" 'latex-help))))
(setq reftex-plug-into-AUCTeX t)
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)

;; (require 'auto-complete-auctex)

;; Invoke Kupfer with name of current buffer:
(defun buffer-file-to-kupfer () 
  "Opens the current file in Kupfer" 
  (interactive) 
  (cond ((and buffer-file-name (file-exists-p buffer-file-name)) 
         (call-process-shell-command (concat "kupfer " buffer-file-name))) 
        ;; dired handling 
        ((eq major-mode 'dired-mode) 
         (dired-do-shell-command "kupfer * " 
                                 current-prefix-arg 
                                 (dired-get-marked-files t current-prefix-arg)))
        ;; buffer-menu mode 
        ((and (eq major-mode 'Buffer-menu-mode) 
              (file-exists-p (buffer-file-name (Buffer-menu-buffer nil)))) 
         (call-process-shell-command 
          (concat "kupfer \"" (buffer-file-name (Buffer-menu-buffer nil)) "\""))) 
        (t 
         (error "Not visiting a file or file doesn't exist")))) 

;; Invoke kupfer with region as text:
(defun region-to-kupfer (start end) 
  "Opens the contents of the region in Kupfer as text." 
  (interactive "r")

  (setq text (buffer-substring start end))
  (call-process-shell-command (concat "echo '" text "' | kupfer")))

;; Invoke kupfer with current line as text:
(defun line-to-kupfer () 
  "Opens the contents of the current line in Kupfer as text,
with leading and trailing spaces removed." 

  (interactive) 

  (save-excursion
    (beginning-of-line)
    (if (setq first-non-blank-pos 
              (re-search-forward "^[[:space:]]*" 
                                 (line-end-position) t))
        (setq beg first-non-blank-pos)
      (setq beg (line-beginning-position)))
    (end-of-line)

    ;; There must be a nonspace character for there to be trailing
    ;; spaces!
    (if (setq next-to-last-non-blank-pos 
              (re-search-backward "[^[:space:]][[:space:]]*$" 
                                  (line-beginning-position) t))
        (setq end (+ next-to-last-non-blank-pos 1))
      (setq end (line-end-position))))

  (setq text (buffer-substring beg end))
  (call-process-shell-command (concat "echo '" text "' | kupfer")))

;; Sending stuff to Kupfer
(global-set-key "\C-cl" 'line-to-kupfer) 
(global-set-key "\C-cw" 'region-to-kupfer) 
(global-set-key "\C-cq" 'buffer-file-to-kupfer)

(require 'dired-x)
(setq-default dired-omit-files-p t) ; Buffer-local variable
(setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))

(add-hook 'dired-load-hook
          (lambda ()
            (load "dired-x")
            ;; Set dired-x global variables here.  For example:
            ;; (setq dired-guess-shell-gnutar "gtar")
            ;; (setq dired-x-hands-off-my-keys nil)
            ))

;; Make M-up go to parent directory in dired mode
(add-hook 'dired-mode-hook
          '(lambda ()
             (define-key dired-mode-map [(meta up)] 'dired-up-directory)))

(require 'sunrise)
(require 'sunrise-modeline)
(require 'sunrise-checkpoint)
(require 'sunrise-popviewer)
(require 'sunrise-tree)

(add-to-list 'auto-mode-alist '("\\.srvm\\'" . sunrise-virtual-mode))

(setq sunrise-cursor-follows-mouse nil)
(define-key sunrise-mode-map [mouse-1]        nil)
(define-key sunrise-mode-map [mouse-movement] nil)

(define-key sunrise-mode-map [backtab] 'sunrise-change-window)

(defun sunrise-reset-panes ()
      "Hard-reset SC panes."
      (interactive)
      (when sunrise-running (sunrise-setup-windows)))

;;; Modified to refrain from opening a new frame when browsing a (pdf,
;;; html etc.) file
(defun sunrise-browse-file (&optional file)
  "Display the selected file in the default web browser."
  (interactive)
  (unless (featurep 'browse-url)
    (error "ERROR: Feature browse-url not available!"))
  (setq file (or file (dired-get-filename)))
  (sunrise-save-selected-window
   ;; I don't want a viewer window or frame to open!
   ;; (sunrise-select-viewer-window)
   (let ((buff (current-buffer)))
     (browse-url (concat "file://" file))
     (unless (eq buff (current-buffer))
       (sunrise-scrollable-viewer (current-buffer)))))
  (message "Browsing \"%s\" in web browser" file))

;;; Modified to set `dired-directory' buffer-local variable
;;; and thus prevent an error from ocurring in dired
(defun sunrise-tree-list (dir)
  "Return the list of subdirectories in DIR."
  (setq dired-directory dir)
  (let ((entries (directory-files dir 'full)) dirs entry rel-entry)
    (while entries
      (setq entry (car entries)
            rel-entry (file-relative-name entry (concat entry "/.."))
            entries (cdr entries))

      (cond ((eq ?. (string-to-char (substring entry -1)))
             (ignore))

            ((and dired-omit-mode (eq ?. (string-to-char rel-entry)))
             (ignore))

            ((file-directory-p entry)
             (setq dirs (cons entry dirs)))

            ((and (not sunrise-tree-omit-archives) (sunrise-avfs-directory-p entry))
             (setq dirs (cons (sunrise-tree-avfs-dir entry) dirs)))

            (t (ignore))))
    (nreverse dirs)))

(defun open-dir-in-sunrise ()
  (interactive)
  (save-excursion
    (sunrise-dired (ffap-guess-file-name-at-point))))

(global-set-key (kbd "C-x C-j") 'open-dir-in-sunrise)

;;; figlet definitions for Emacs.  (C) Martin Giese
;;;
;;; Use this to separate sections in TeX files, Program source, etc.
;;;
;;; customize the figlet-font-dir variable below to point to your
;;; figlet font directory.
;;;
;;; M-x figlet      to get a figlet comment in standard font.
;;; C-u M-x figlet  to be asked for the font first.
;;; M-x banner      for an old-fashioned banner font.
;;;
;;; These functions use comment-region to wrap the figlet output 
;;; in comments.
;;;

(defconst figlet-font-dir "/usr/share/figlet")
(defconst figlet-font-file-regexp "\\.flf$")
(defconst figlet-match-font-name-regexp "^\\([^.]*\\)\\.flf$")

(defun figlet-font-name-for-file (filename)
  (string-match figlet-match-font-name-regexp filename)
  (match-string 1 filename))

(defun figlet-font-names ()
  (mapcar 'figlet-font-name-for-file
      (directory-files figlet-font-dir nil figlet-font-file-regexp)))

(defun read-figlet-font (prompt)
  (let* ((figlet-fonts (figlet-font-names))
     (font-alist (mapcar (lambda (x) (list x)) figlet-fonts)))
    (completing-read prompt font-alist)))

(defun call-figlet (font string)
  (push-mark)
  (call-process "figlet" nil (current-buffer) nil
        "-f" (if (null font) "standard" font)
        string
        )
  (exchange-point-and-mark))

(defun figlet-block-comment-region ()
  (comment-region (region-beginning) (region-end)
          (if (member major-mode 
                  '(emacs-lisp-mode
                lisp-mode
                scheme-mode))
              3			; 3 semicolons for lisp
            nil)
          ))

(defun figlet (s &optional font)
  (interactive 
   (if current-prefix-arg
       (let 
       ((font (read-figlet-font "Font: "))
        (text (read-string "FIGlet Text: ")))
     (list text font))
     (list (read-string "FIGlet Text: ") nil)))
  (save-excursion
    (call-figlet font s)
    (figlet-block-comment-region)
    ))

(defun banner (s) 
  (interactive "sBanner Text: ")
  (figlet s "banner"))

(require 'system-packages)
(setq system-packages-use-sudo t)

;;; Open custom agenda (see variable org-agenda-custom-commands). This
;;; splits window vertically, which is ugly. We'll fix this below.
;;; Update: I have changed variable org-agenda-window-setup so that
;;; the agenda opens in the current window, with no splitting.
(org-agenda nil "i")
(split-window-horizontally)
(find-file "~/Documents/OrgFiles/todo.org")
(maximize-current-frame)

;;; Second frame: shell and xonsh ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(make-frame)
(other-frame -1)
(maximize-current-frame)

;;; disabled
;; (ansi-term "/home/fnaufel/.local/bin/xonsh" "xonsh")

;;; Bash shell (splits window automatically)
(shell)
(sleep-for 3)
(comint-send-string (get-buffer-process (shell)) "cd /home/fnaufel/\n")
(sleep-for 1)
(dirs)

;;; Third frame: sunrise ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(make-frame)
(other-frame -1)
(maximize-current-frame)
(sunrise "/home/fnaufel" "/home/fnaufel/Downloads")
;; Set tree view for left-hand pane...
;; (sunrise-tree-view)
;; ...and for right-hand pane
;; (other-window 1)
;; (sunrise-tree-view)
;; go back to left-hand pane
;; (other-window 1)

;; ;;; Go back to initial frame
(other-frame -1)
